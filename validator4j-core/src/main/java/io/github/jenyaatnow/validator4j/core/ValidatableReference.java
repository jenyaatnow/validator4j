package io.github.jenyaatnow.validator4j.core;

import lombok.NonNull;

import java.util.Collection;
import java.util.function.Consumer;

/**
 * This class is the top in the inheritance hierarchy of V-classes. Each autogenerated {@code VUserDefinedClass}
 * transitively inherits this class. It contains a basic functionality to provide validation capabilities
 * for all inheritors.
 *
 * @param <TARGET> type of validated value.
 */
public abstract class ValidatableReference<TARGET> {

    /**
     * Root validation object property path constant.
     */
    protected static final String PATH_ROOT = "";

    /**
     * Path of property represented by instance of this class.
     */
    protected final String path;

    /**
     * Validated value itself.
     */
    protected final TARGET value;

    /**
     * Validation errors container.
     */
    final ErrorsCollector errors;

    /**
     * Validation rule actions prepared to perform deferred validation.
     */
    final Collection<Runnable> ruleActions;

    /**
     * Operation that uses in order to reject invalid value and put {@link ValidationError} to errors container.
     */
    private final Consumer<String> reject;

    protected ValidatableReference(@NonNull final String path,
                                   final TARGET value,
                                   @NonNull final ValidationContext ctx)
    {
        this.path = path;
        this.value = value;
        this.errors = ctx.getErrors();
        this.ruleActions = ctx.getRuleActions();

        this.reject = message -> {
            final var error = ValidationError.of(this.path, message);
            this.errors.add(error);
        };
    }

    /**
     * Prepares validation rule to perform deferred validation. Doesn't perform any validation itself.
     * Validation will happen with {@link ValidatableObject#validate()} call. Example:
     *     <pre>
     *     {@code
     *     final VUser vUser = ...;
     *     vUser.getId().validate((id, reject) -> {
     *         if (id < 1) {
     *             reject.accept("Id should be positive number");
     *         }
     *     })
     *     }
     *     </pre>
     * Above notation is semantically equivalent to following sample using {@link ValidatableReference#reject(String)}:
     *     <pre>
     *     {@code
     *     final VUser vUser = ...;
     *     final ValidatableValue<Integer> validatableId = vUser.getId();
     *     final Integer id = validatableId.get();
     *     if (id < 1) {
     *         validatableId.reject("Id should be positive number");
     *     }
     *     }
     *     </pre>
     *
     * @param validationRule validation rule.
     */
    public final void validate(@NonNull final ValidationRule<TARGET> validationRule) {
        ruleActions.add(() -> validationRule.validate(value, reject));
    }

    /**
     * Prepares rejection of underlying validated value. Rejection itself will happen
     * with {@link ValidatableObject#validate()} call. Example:
     *     <pre>
     *     {@code
     *     final VUser vUser = ...;
     *     final ValidatableValue<Integer> validatableId = vUser.getId();
     *     final Integer id = validatableId.get();
     *     if (id < 1) {
     *         validatableId.reject("Id should be positive number");
     *     }
     *     }
     *     </pre>
     * Above notation is semantically equivalent to following sample
     * using {@link ValidatableReference#validate(ValidationRule)}:
     *     <pre>
     *     {@code
     *     final VUser vUser = ...;
     *     vUser.getId().validate((id, reject) -> {
     *         if (id < 1) {
     *             reject.accept("Id should be positive number");
     *         }
     *     })
     *     }
     *     </pre>
     *
     * @param message error message.
     */
    public final void reject(@NonNull final String message) {
        ruleActions.add(() -> reject.accept(message));
    }

    /**
     * Returns underlying validated value.
     *
     * @return validated value.
     */
    public TARGET get() {
        return value;
    }
}
